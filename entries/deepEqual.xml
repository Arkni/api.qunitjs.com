<entry type="method" name="deepEqual">
  <signature>
    <argument name="actual" type="String,Number,Boolean,Array,PlainObject,Date,RegExp,Function,Nan,Null,Undefined">
      <desc>Expression being tested</desc>
    </argument>
    <argument name="expected" type="String,Number,Boolean,Array,PlainObject,Date,RegExp,Function,Nan,Null,Undefined">
      <desc>Known comparison value</desc>
    </argument>
    <argument name="message" type="String">
      <desc>A short description of the assertion</desc>
    </argument>
  </signature>
  <desc>
    A deep recursive comparison assertion, working on primitive types, arrays, objects, regular expressions, dates and functions.
  </desc>
  <longdesc>
    <p>The <code>deepEqual()</code> assertion can be used just like <code>equal()</code> and is a better choice in most cases. Instead of the simple comparison operator (<code>==</code>), it uses the more accurate comparison operator (<code>===</code>). That way, <code>undefined</code> doesn't equal <code>null</code>, <code>0</code>, or the empty string (<code>""</code>). It also compares the content of objects so that <code>{ key: value }</code> is equal to <code>{ key: value }</code>, even when comparing two objects with distinct identities.</p>

    <p><code>notDeepEqual()</code> can be used to explicitly test deep, strict inequality.</p>
  </longdesc>
  <example height="250">
    <desc>Compare the value of two objects.</desc>
<code><![CDATA[
test( "deepEqual test", function() {
  var obj = { foo: "bar" };

  deepEqual( obj, { foo: "bar" }, "Two objects can be the same in value" );
});
]]></code>
  </example>

  <category slug="assert"/>
</entry>
